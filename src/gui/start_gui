#!/usr/bin/env python3
# kate: indent-mode: python; indent-pasted-text false; indent-width 4; replace-tabs: on;
# vim: tabstop=4 softtabstop=4 shiftwidth=4 expandtab

import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk
from gi.repository import GdkPixbuf
from gi.repository import Gdk
from gi.repository import Gio
from gi.repository import GLib
from gi.repository import GObject
import sys
import os
import subprocess
import signal
import os.path
import re
from collections import Counter
from time import sleep, time
import csv
from petsys import daqd, info, bias, fe_power
from fcntl import fcntl, F_GETFL, F_SETFL
from os import O_NONBLOCK, read
from matplotlib.backends.backend_gtk3agg import (FigureCanvasGTK3Agg as FigureCanvas)
from matplotlib.figure import Figure

import numpy as np

class GUI:
    def __init__ (self):
        self.builder = Gtk.Builder()
        self.builder.add_from_file('gui/gui_layout.glade')
        
        self.MainWindow = self.builder.get_object("MainWindow")

        self.processWindow = self.builder.get_object("executeWindow")
        
        self.readTempWindow = self.builder.get_object("readTempWindow")
        self.readTempPlotWindow = self.builder.get_object("readTempPlotWindow")

        self.builder.connect_signals(self)
        
        self.__daqd_switch_handle_set = False
       
        self.__daqdPid = None
        self.__process = None
        self.__temperatureProcess = None
  
        self.tempPlot = None
        self.canvas = None
        self.__terminalPid = None
       
        self.__workingFolder = None

        self.__fem_switch_handle_set = False
        self.__bias_switch_handle_set = False

        self.__scroll = True
        self.__usedStopButton = False
     
        self.__usedTempStopButton = False
        self.__tempLogFileName = None
        self.__initialiseTempPlot = False

        self.hasSensorInfo = False

    def on_executeStopButton_clicked(self, button):
        if self.__process is not None:
            if self.show_confirmation_dialog("","Stop the process?",  self.processWindow):
                self.__usedStopButton = True
                os.killpg(os.getpgid(self.__process.pid), signal.SIGTERM)
        return True

    def on_scrollButton_toggled(self, button):
        isActive = self.builder.get_object("executeScrollButton").get_active()
        if isActive:
            self.__scroll = True
        else:
            self.__scroll = False
        
    def execute(self,command, processName ="", message1="", message2=""):
        
        self.__usedStopButton = False
        self.__process = subprocess.Popen(command, shell=True, bufsize=1, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, preexec_fn=os.setsid)

        flags = fcntl(self.__process.stdout, F_GETFL) # get current p.stdout flags
        fcntl(self.__process.stdout, F_SETFL, flags | O_NONBLOCK)
        
        flags = fcntl(self.__process.stderr, F_GETFL) # get current p.stdout flags
        fcntl(self.__process.stderr, F_SETFL, flags | O_NONBLOCK)

        # turn off sensitive property of all widgets that are not on the execute process window
        for widget in self.builder.get_objects():
            if widget.find_property("sensitive") is not None:
                if ("execute" in  Gtk.Buildable.get_name(widget)) or ("readTemp" in  Gtk.Buildable.get_name(widget)):
                    widget.set_sensitive(True)
                else:
                    widget.set_sensitive(False)
        
        self.builder.get_object("executeScrollButton").set_sensitive(True)
        self.builder.get_object("executeStopButton").set_sensitive(True)
        self.processWindow.set_title("%s (running)" % processName)
        self.processWindow.show()
        self.builder.get_object("executeSpinner").start()

        GLib.io_add_watch(self.__process.stdout, # file descriptor
                          GLib.IO_IN,  # condition
                          self.write_to_textview ) # callback

        
        GLib.io_add_watch(self.__process.stderr, # file descriptor
                          GLib.IO_IN,  # condition
                          self.write_to_textview ) # callback

        data = [processName, message1, message2]
            
        self.timeout_id = GLib.timeout_add(1000, self.check_if_finished, data)


    def read_temperature(self,command, processName ="", message1="", message2=""):
        
        self.__usedTempStopButton = False
        self.__temperatureProcess = subprocess.Popen(command, shell=True, bufsize=0, stdout=subprocess.PIPE, stderr=subprocess.PIPE, preexec_fn=os.setsid)

        flags = fcntl(self.__temperatureProcess.stdout, F_GETFL) # get current p.stdout flags
        fcntl(self.__temperatureProcess.stdout, F_SETFL, flags | O_NONBLOCK)
        
        flags = fcntl(self.__temperatureProcess.stderr, F_GETFL) # get current p.stdout flags
        fcntl(self.__temperatureProcess.stderr, F_SETFL, flags | O_NONBLOCK)


        self.readTempWindow.set_title("Read Temperature Sensors (running)")
        #self.readTempWindow.show()
        self.builder.get_object("readTempSpinner").start()

        GLib.io_add_watch(self.__temperatureProcess.stdout, # file descriptor
                          GLib.IO_IN,  # condition
                          self.write_to_textview_temp ) # callback

        
        GLib.io_add_watch(self.__temperatureProcess.stderr, # file descriptor
                          GLib.IO_IN,  # condition
                          self.write_to_textview_temp ) # callback

        data = [processName, message1, message2]
            
        self.timeout_id = GLib.timeout_add(1000, self.check_if_temp_finished, data)
    
    def check_if_finished(self, data):
        message1 = data[1]
        message2 = data[2]
        if self.__process is None:
            return True
        if self.__process.poll() is not None:
            self.builder.get_object("executeSpinner").stop()
            GLib.source_remove(self.timeout_id)
            # Make all widgets sensitive again...


            for widget in self.builder.get_objects():
                if widget.find_property("sensitive") is not None:
                    widget.set_sensitive(True)
            if self.builder.get_object("acqRealTimeProcess").get_active():
                self.builder.get_object("acqSaveRawLabel").set_sensitive(True)
                self.builder.get_object("acqSaveRawCheck").set_sensitive(True)
                self.builder.get_object("acqProcessWhenFinishedLabel").set_sensitive(False)
                self.builder.get_object("acqProcessWhenFinishedCheck").set_sensitive(False)
                self.builder.get_object("acqProcessWhenFinishedCheck").set_active(False)
            else:
                self.builder.get_object("acqSaveRawLabel").set_sensitive(False)
                self.builder.get_object("acqSaveRawCheck").set_sensitive(False)
                self.builder.get_object("acqSaveRawCheck").set_active(False)
                self.builder.get_object("acqProcessWhenFinishedLabel").set_sensitive(True)
                self.builder.get_object("acqProcessWhenFinishedCheck").set_sensitive(True)
                return False


            self.builder.get_object("executeScrollButton").set_sensitive(False)
            self.builder.get_object("executeStopButton").set_sensitive(False)
            self.builder.get_object("execStartButton").set_sensitive(False)
            if not self.__usedStopButton:
                self.processWindow.set_title("%s (finished)" % data[0])
            else:
                self.processWindow.set_title("%s (stopped by user)" % data[0])
           
            comboBox =  self.builder.get_object("processingConvertBoxOptions")
            self.on_processingConvertBoxOptions_changed(comboBox)

            textView = self.builder.get_object("executeTextView")
            self.scroll_to_end(textView)
            buf = textView.get_buffer()
            buf.insert_at_cursor("\n\n")
            self.__process = None
            if message1 != "" and not self.__usedStopButton:
                self.show_info_dialog(message1, message2, self.processWindow)
        return True
            
   

    def check_if_temp_finished(self, data):
        message1 = data[1]
        message2 = data[2]
        if self.__temperatureProcess is None:
            return True
        if self.__temperatureProcess.poll() is not None:
            self.builder.get_object("readTempSpinner").stop()
        
            if not self.__usedTempStopButton:
                self.readTempWindow.set_title("%s (finished)" % data[0])
            else:
                self.readTempWindow.set_title("%s (stopped by user)" % data[0])
        
            textView = self.builder.get_object("readTempTextView")
            self.scroll_to_end(textView)
            buf = textView.get_buffer()
            buf.insert_at_cursor("\n\n")
            self.__temperatureProcess = None
            if message1 != "" and not self.__usedTempStopButton:
                self.show_info_dialog(message1, message2, self.processWindow)
        
        return True

    def clean_input_request(self,line):
        line = re.sub(r"WARNING:|\[Y/n\]", "", line)  # Remove targets
        return line.strip()  # Trim whitespace

    def write_to_textview(self, fd, condition):
        if condition == GLib.IO_IN: 
            char = fd.read().decode() 
            tview = self.builder.get_object("executeTextView")
            buf = self.builder.get_object("executeTextView").get_buffer()
        
            if "Python:: Acquired" in char:
                if "\r" in char:
                    char = char[:-1]
                nLines =  buf.get_line_count()
                lineIterStart = buf.get_iter_at_line_index(nLines-1,0)
                lineIterEnd = buf.get_end_iter()
                buf.delete(lineIterStart, lineIterEnd)
                buf.place_cursor(buf.get_end_iter())
            buf.insert_at_cursor(char)
          
            if "[Y/n]" in char: 
                message=self.clean_input_request(char)
                if self.show_confirmation_dialog( message, "WARNING", self.processWindow):
                    self.__process.stdin.write("Y\n".encode('utf-8'))
                else:
                    self.__process.stdin.write("N\n".encode('utf-8'))
                self.__process.stdin.flush()
            if self.__scroll:
                self.scroll_to_end(self.builder.get_object("executeTextView"))
            return True 
        else:
            return False 
    
    def write_to_textview_temp(self, fd, condition):
        if condition == GLib.IO_IN: 
            char = fd.read().decode() 
            tview = self.builder.get_object("readTempTextView")
            buf = self.builder.get_object("readTempTextView").get_buffer()
        
            if "Python:: Acquired" in char:
                if "\r" in char:
                    char = char[:-1]
                nLines =  buf.get_line_count()
                lineIterStart = buf.get_iter_at_line_index(nLines-1,0)
                lineIterEnd = buf.get_end_iter()
                buf.delete(lineIterStart, lineIterEnd)
                buf.place_cursor(buf.get_end_iter())
            buf.insert_at_cursor(char)
                
            if self.__scroll:
                self.scroll_to_end(self.builder.get_object("readTempTextView"))
            return True 
        else:
            return False 
    
    def scroll_to_end(self,textview):
        i = textview.props.buffer.get_end_iter()
        mark = textview.props.buffer.get_insert()
        textview.props.buffer.place_cursor(i)
        textview.scroll_to_mark(mark, 0.0, True, 0.0, 1.0)

    def on_MainWindow_delete_event(self, MainWindow, data): 
        if self.show_confirmation_dialog("This will close any running process","Exit?"):
            if self.__process is not None:
                os.killpg(os.getpgid(self.__process.pid), signal.SIGTERM)
            if self.__daqdPid != None and self.is_daqd_running():
                os.kill(int(self.__daqdPid), signal.SIGTERM)
                sleep(0.3)
                if self.__terminalPid != None:
                    os.kill(int(self.__terminalPid), signal.SIGKILL)    
            Gtk.main_quit()
        return True
                                
    def on_executeWindow_delete_event(self, window, data): 
        if self.__process is not None:
            if self.show_confirmation_dialog("Closing window will stop the running process. Proceed?", "", self.processWindow):
                os.killpg(os.getpgid(self.__process.pid), signal.SIGTERM)
                window.hide()
        else:
            if self.show_confirmation_dialog("","Close window?", self.processWindow):
                window.hide()
        return True

    def on_readTempWindow_delete_event(self, window, data): 
        if self.__temperatureProcess is not None:
            if self.show_confirmation_dialog("Closing window will stop temperature monitoring. Proceed?", "", self.readTempWindow):
                os.killpg(os.getpgid(self.__temperatureProcess.pid), signal.SIGTERM)
                window.hide()
        else:
            if self.show_confirmation_dialog("","Close window?", self.readTempWindow):
                window.hide()
        return True

        # Main menu handler functions       

    def on_menuFileQuit_activate(self, menuFileQuit): # quit with Quit button
        if self.show_confirmation_dialog("This will close any running process","Exit?"):
            if self.__process is not None:
                os.killpg(os.getpgid(self.__process.pid), signal.SIGTERM)
            if self.__daqdPid != None and self.is_daqd_running():
                os.kill(int(self.__daqdPid), signal.SIGTERM)
                sleep(0.3)
                if self.__terminalPid != None:
                    os.kill(int(self.__terminalPid), signal.SIGKILL)    
            Gtk.main_quit()
        
    def on_menuHelpAbout_activate(self, menuHelpAbout): 
        about = Gtk.AboutDialog.new()
        about.set_transient_for(self.MainWindow)
        about.set_logo(GdkPixbuf.Pixbuf.new_from_file("gui/logo_PETsys2.png"))
        about.set_website("http://www.petsyselectronics.com")
        about.set_website_label("petsyselectronics.com")
        about.set_program_name("TOFPET2 Data Acquisition Software")
        about.set_authors(["Ricardo Bugalho","Luis Ferramacho"])
        about.show()
        
    def on_menuHelpDoc_activate(self, menuHelpDoc):
        Gtk.show_uri_on_window(None, "https://www.petsyselectronics.com/web/private/folder/18/d2Vic2l0ZS9kb2N1bWVudGF0aW9uL1RPRlBFVDIgRG93bmxvYWRzL0RvY3VtZW50YXRpb24=/2",0)
 
    def on_daqdSwitch_state_set(self, daqdSwitch, isON):

        isGBE = self.builder.get_object("radioButtonGBE").get_active()
      
        if isGBE:
            command = "./daqd --socket-name /tmp/d.sock --daq-type GBE"
        else:
            command = "./daqd --socket-name /tmp/d.sock --daq-type PFP_KX7"
            
       # command2 = "gnome-terminal -e 'bash -c \"%s; exec bash\"'" % command
        command2 = "xterm -hold -e \"%s\"" % command
        if isON:   
            # Check if there are other instances of daqd
            if not self.__daqd_switch_handle_set:
                if self.is_daqd_running():
                    daqdPids = subprocess.check_output(["pidof", "daqd"])
                    pidsToKill = daqdPids.decode("ascii").split(" ")

                    if self.show_confirmation_dialog("There are other instances of daqd running in the system. Kill them and open a new instance?"):
                        for pid in pidsToKill:
                            os.kill(int(pid), signal.SIGTERM)
                    else:
                        self.__daqdPid = pidsToKill[0]
                        return

                #Check if socket and shm files exist
                if os.path.exists('/tmp/d.sock'):
                    subprocess.call("rm /tmp/d.sock", shell=True) 

                if os.path.exists('/dev/shm/daqd_shm'):
                    subprocess.call("rm /dev/shm/daqd_shm", shell=True) 

                #Open ./daqd
                daqdOpenPipe = subprocess.Popen(command2, shell=True)                
                sleep(1.5)

                # Check if daqd opened successfully and store pids of processes
                if self.is_daqd_running():
                    daqdPid = subprocess.check_output(["pidof", "daqd"])
                    self.__daqdPid = daqdPid.decode("ascii").split(" ")[0]
                else:
                    self.show_error_dialog("daqd server was unable to start correctly. Please check error message in the terminal and retry")
                    self.__daqdPid = None
                    self.__daqd_switch_handle_set = True
                    daqdSwitch.set_active(False)
                    self.__daqd_switch_handle_set = False
                    return True

                terminalPid = subprocess.check_output(["pidof", "xterm"])
                terminalPids = terminalPid.decode("ascii").split(" ")
                for pid in terminalPids:
                    pid2 = pid.strip('\n')
                    command3 = "ps -o etime= -p \"%s\"" % pid2
                    time =  subprocess.check_output(command3, shell=True ) 
                    time2 = time.decode("ascii").strip('\n')
                    if time2.count(':') == 1 and time2.count('-')==0:
                        timeSec = sum(x * int(t) for x, t in zip([60, 1], time2.split(":")))
                    elif time2.count(':') == 2 and time2.count('-') ==0:
                        timeSec = sum(x * int(t) for x, t in zip([3600,60, 1], time2.split(":")))
                    else:
                        continue
                    if timeSec < 5:
                        self.__terminalPid = pid2
                #Check if power is on to update power button
                connection = daqd.Connection()
                for portID, slaveID in connection.getActiveFEBDs(): 
                    femPowerStatus = fe_power.get_fem_power_status(connection, portID, slaveID)
                    if not femPowerStatus and self.builder.get_object("femOnOffSwitch").get_active(): 
                        self.setPowerSwitchesStatus(True)
                    if femPowerStatus and not self.builder.get_object("femOnOffSwitch").get_active():
                        self.setPowerSwitchesStatus(False)
        else:
            if not self.__daqd_switch_handle_set:
                isDaqdPresent = subprocess.call(["pidof", "daqd"], stdout= subprocess.PIPE) == 0
                if self.__daqdPid != None and self.is_daqd_running():
                    os.kill(int(self.__daqdPid), signal.SIGTERM)
                    sleep(0.3)
                if self.__terminalPid != None:
                    os.kill(int(self.__terminalPid), signal.SIGKILL)
      
    def is_daqd_running(self):
        isDaqdPresent = subprocess.call(["pidof", "daqd"], stdout= subprocess.PIPE) == 0
        return isDaqdPresent

    def setPowerSwitchesStatus(self, isFemPowerOn):
        if isFemPowerOn:
            self.__fem_switch_handle_set = True
            self.builder.get_object("femOnOffSwitch").set_active(True)
            self.builder.get_object("biasOnOffLabel").set_sensitive(True)
            self.builder.get_object("biasOnOffSwitch").set_sensitive(True)
            self.__fem_switch_handle_set = False
        else:
            self.__fem_switch_handle_set = True
            self.builder.get_object("femOnOffSwitch").set_active(False)
            self.builder.get_object("biasOnOffLabel").set_sensitive(False)
            self.builder.get_object("biasOnOffSwitch").set_sensitive(False)
            self.__fem_switch_handle_set = False

    def on_dataFolderChooseButton_clicked(self, dataFolderChooseButton):   
        folderChooser = self.builder.get_object("dataFolderChooser")
        folderEntry = self.builder.get_object("dataFolderEntry")
        folderChooser.set_default_size(1200, 400)

        response = folderChooser.run()
        if response == Gtk.ResponseType.OK:
            folderEntry.set_text(folderChooser.get_filename())
            self.__workingFolder = folderChooser.get_filename()+"/"
            self.check_bias_settings_file()
            self.check_disc_settings_file()
            
        elif response == Gtk.ResponseType.CANCEL:
            folderChooser.hide()

        folderChooser.hide()
        
    def check_bias_settings_file(self):
        filename = self.__workingFolder + "bias_settings.tsv"
        if not os.path.exists(filename):
            return
            
        # Check if bias settings file exists and is not custom made (all 4 last collumns have equal values)
        offset = []
        prebd = []
        bd = []
        ov = []
        with open(filename) as csvfile:
            reader = csv.DictReader(csvfile, delimiter='\t')
            for row in reader:
                offset.append(row['Offset'])
                prebd.append(row['Pre-breakdown'])
                bd.append(row['Breakdown'])
                ov.append(row['Overvoltage'])
             
        if (len(set(offset)) == 1 and len(set(prebd)) == 1 and len(set(bd)) == 1 and len(set(ov)) == 1):
            self.builder.get_object("biasSpinButton1").set_value(float(prebd[0]))
            self.builder.get_object("biasSpinButton2").set_value(float(bd[0]))
            self.builder.get_object("biasSpinButton3").set_value(float(ov[0]))
            self.show_info_dialog("WARNING: Simple Bias Settings file detected in working folder", "Values were updated in the Bias Settings Section")
        else:
            self.builder.get_object("biasSpinButton1").set_value(0)
            self.builder.get_object("biasSpinButton2").set_value(0)
            self.builder.get_object("biasSpinButton3").set_value(0)
            self.show_info_dialog("WARNING: Custom Bias Settings file detected in working folder", "Save button in Bias Settings Section can override them")

    def check_disc_settings_file(self):
        filename = self.__workingFolder + "disc_settings.tsv"
        if not os.path.exists(filename):
            return

        # Check if bias settings file exists and is not custom made (all 4 last collumns have equal values)
        vth_t1 = []
        vth_t2 = []
        vth_e = []
        with open(filename) as csvfile:
            reader = csv.DictReader(csvfile, delimiter='\t')
            for row in reader:
                vth_t1.append(row['vth_t1'])
                vth_t2.append(row['vth_t2'])
                vth_e.append(row['vth_e'])
                          
        if (len(set(vth_t1)) == 1 and len(set(vth_t2)) == 1 and len(set(vth_e)) == 1):
            self.builder.get_object("threshSpinButton1").set_value(float(vth_t1[0]))
            self.builder.get_object("threshSpinButton2").set_value(float(vth_t2[0]))
            self.builder.get_object("threshSpinButton3").set_value(float(vth_e[0]))
            self.show_info_dialog("WARNING: Simple Discriminator Thresholds Settings file detected in working folder", "Values were updated in the ASIC Thresholds Settings Section")
        else:
            self.builder.get_object("threshSpinButton1").set_value(0)
            self.builder.get_object("threshSpinButton2").set_value(0)
            self.builder.get_object("threshSpinButton3").set_value(0)
            self.show_info_dialog("WARNING: Custom Discriminator Thresholds Settings file detected in working folder", "Caution: Save button in ASIC Thresholds Settings Section will overwrite it!")

    def on_dataFolderEntry_activate(self, dataFolderEntry):
        folderExists= os.path.exists(dataFolderEntry.get_text())
        if not folderExists:
            if self.show_confirmation_dialog("No such folder exists. Create folder?"):
                subprocess.call("mkdir "+ dataFolderEntry.get_text(), shell=True) 
                self.__workingFolder = dataFolderEntry.get_text() + "/"
            else: 
                return True
        else:
            self.__workingFolder = dataFolderEntry.get_text() + "/"
            self.check_bias_settings_file()
            self.check_disc_settings_file()
            
    def on_biasApplyButton_clicked(self, biasApplyButton):
        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return
        if not os.path.exists(self.__workingFolder + "config.ini"):
            self.show_error_dialog("'config.ini' file not found in the working folder. Please use the detect and save button to create one.")
            return
        if not os.path.exists(self.__workingFolder + "bias_calibration.tsv"):
            self.show_error_dialog("Bias Calibration file not detected in working folder. Please use the detect and save button in 'System Configuration' section.")
            return

        preBD = self.builder.get_object("biasSpinButton1").get_value()
        BD = self.builder.get_object("biasSpinButton2").get_value()
        OV = self.builder.get_object("biasSpinButton3").get_value()
            
        configFile = self.__workingFolder + "config.ini"
        outFile = self.__workingFolder + "bias_settings.tsv"
        
        if os.path.exists(outFile):
            if not self.show_confirmation_dialog("A Bias Settings file exists in the working folder. Overwrite?"):
                return
            
        command = "./make_simple_bias_settings_table --config %s --offset 0.75 --prebd %.2f --bd %.2f --over %.2f -o %s" % (configFile, preBD, BD, OV, outFile)
         
        subprocess.call(command, shell=True)

        self.show_info_dialog("Bias Settings saved","")
       
    def on_biasEditButton_clicked(self, biasEditButton):
        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return
        if not os.path.exists(self.__workingFolder + "bias_settings.tsv"):
            self.show_error_dialog("Please use the save button before editing the bias settings file.")
        appChooser = self.builder.get_object("applicationChooser")
        response = appChooser.run()
        if response == Gtk.ResponseType.OK:
            info = appChooser.get_app_info()
            biasFile = Gio.File.new_for_path(self.__workingFolder + "bias_settings.tsv")
            info.launch([biasFile], None)
        appChooser.hide()
    
    def on_threshEditButton_clicked(self, threshEditButton):
        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return
        if not os.path.exists(self.__workingFolder + "disc_settings.tsv"):
            self.show_error_dialog("Please use the save button before editing the discriminator settings file.")
        appChooser = self.builder.get_object("applicationChooser")
        response = appChooser.run()
        if response == Gtk.ResponseType.OK:
            info = appChooser.get_app_info()
            discFile = Gio.File.new_for_path(self.__workingFolder + "disc_settings.tsv")
            info.launch([discFile], None)
        appChooser.hide()
    
    def on_editMapsButton_clicked(self, mapsEditButton):
        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return
        if not os.path.exists(self.__workingFolder + "map_channel.tsv"):
            self.show_error_dialog("Please use the detect and save button before editing the channel and trigger maps.")
        appChooser = self.builder.get_object("applicationChooser")
        response = appChooser.run()
        if response == Gtk.ResponseType.OK:
            info = appChooser.get_app_info()
            file1 = Gio.File.new_for_path(self.__workingFolder + "map_channel.tsv")
            file2 = Gio.File.new_for_path(self.__workingFolder + "map_trigger.tsv")
            info.launch([file1, file2], None)
        appChooser.hide()

    def on_editConfigButton_clicked(self, mapsEditButton):
        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return
        if not os.path.exists(self.__workingFolder + "config.ini"):
            self.show_error_dialog("'config.ini' file not found in the working folder. Please use the detect button and save a valid configuration")
        appChooser = self.builder.get_object("applicationChooser")
        response = appChooser.run()
        if response == Gtk.ResponseType.OK:
            info = appChooser.get_app_info()
            configFile = Gio.File.new_for_path(self.__workingFolder + "config.ini")
            info.launch([configFile], None)
        appChooser.hide()

    def on_threshApplyButton_clicked(self, threshApplyButton):
        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return
        if not os.path.exists(self.__workingFolder + "config.ini"):
            self.show_error_dialog("'config.ini' file not found in the working folder. Please use the detect and save button to create one.")
            return
        if not os.path.exists(self.__workingFolder + "disc_calibration.tsv"):
            self.show_error_dialog("Discriminator Calibration file not detected in working folder. Please perform ASIC calibration.")
            return

        vth_t1 = self.builder.get_object("threshSpinButton1").get_value()
        vth_t2 = self.builder.get_object("threshSpinButton2").get_value()
        vth_e = self.builder.get_object("threshSpinButton3").get_value()
        
        configFile = self.__workingFolder + "config.ini"
        outFile = self.__workingFolder + "disc_settings.tsv"
        if os.path.exists(outFile):
            if not self.show_confirmation_dialog("A Discriminator Threshold Settings file exists in the working folder. Overwrite?"):
                return
            
        command = "./make_simple_disc_settings_table --config %s --vth_t1 %d --vth_t2 %d --vth_e %d -o %s" % (configFile, int(vth_t1), int(vth_t2), int(vth_e), outFile)
         
        subprocess.call(command, shell=True)
        
        self.show_info_dialog("Threshold Settings saved","")

    def on_systemDetectButton_clicked(self, systemButton):
        if not self.is_daqd_running():
            self.show_error_dialog("daqd communication server is not running.")
            return

        self.__febdTopology = {}
        self.__febdNumber = 0 

        connection = daqd.Connection()

        febds = connection.getActiveFEBDs()
        if not febds:
            self.show_error_dialog("No FEB/Ds detected. Please check connections and try again.")
            return True

        tgr = connection.getTriggerUnit()

        is_ekit = (tgr != None) and ([ tgr ] == febds )

        topology_txt = ""
        self.__bias_64p = {}
        if is_ekit:
            system_type_txt = "Detected Evaluation Kit"
            # Auxiliary function to change format depending on whether it's ekit or not
            ffmt = lambda x,y: ""
        else:
            system_type_txt = "Detected SiPM Readout system"
            ffmt = lambda x,y: "port %2d slave %2d: " % (x,y)

            if tgr is not None:
                portID, slaveID = tgr
                topology_txt += "%s CLK&TRIGGER 16\n" % ffmt(portID, slaveID)
    
        for portID, slaveID in connection.getActiveFEBDs():

            d = connection.getUnitInfo(portID, slaveID)
            bias_str_list = []
            for slotID in range(info.bias_slots(d)):
                bias_str = bias.get_str(connection, portID, slaveID, slotID)

                if not bias.has_prom(connection, portID, slaveID, slotID):
                    self.__bias_64p[(portID, slaveID, slotID)] = None
                    bias_str += "*"
                
                bias_str_list.append(bias_str)

        
            topology_txt += "%s FEB/D with %s\n" % (ffmt(portID, slaveID), (", ").join(bias_str_list))
                
        if self.__bias_64p != {}:
            topology_txt += "\n\n*Calibration file required\n\n"
            topology_txt += "\n  Opening configuration window..."
            self.show_info_dialog(system_type_txt, topology_txt)
                    
            hBox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=20)

            self.builder.add_objects_from_file("gui/gui_layout.glade", ("febdConfigDialog","febdConfigDialogBox",""))

            febdConfigBox = self.builder.get_object("febdConfigDialogBox")
            grid = Gtk.Grid()
            febdConfigBox.pack_start(grid, True, True, 0)

            label1 = Gtk.Label("portID")
            label1.set_margin_right(10)
            label1.set_margin_left(10)
            label1.set_property("halign",3)  
            grid.add(label1)

            label2 = Gtk.Label("slaveID")
            label2.set_margin_right(10)
            label2.set_margin_left(10)
            label2.set_property("halign",3)
            grid.attach_next_to(label2, label1, Gtk.PositionType.RIGHT, 1, 1)
            label3 = label2

            max_bias_slots = max([ slotID for portID, slaveID, slotID in connection.getActiveBiasSlots() ]) + 1
            for i in range(2):
                label4 = Gtk.Label("slot %d" % i)
                label4.set_margin_right(10)
                label4.set_margin_left(10)
                label4.set_property("halign", 3)
                grid.attach_next_to(label4, label3, Gtk.PositionType.RIGHT, 2, 1)
                label3 = label4
        
            self.__febdNumber = len(connection.getActiveFEBDs())       
            portLabelList = {}
            slaveLabelList = {}
            fileButtonList = {}
            triggerSpinButtonList = {}
            triggerSpinAdjustmentList = {}
            fileEntryList = {}

            for i, (portID, slaveID) in enumerate(connection.getActiveFEBDs()):
                ps = (portID, slaveID)

                portLabelList[ps] = Gtk.Label()
                portLabelList[ps].set_text("%d" % portID)

                slaveLabelList[ps] = Gtk.Label()
                slaveLabelList[ps].set_text("%d" % slaveID)

                grid.attach(portLabelList[ps], 0, i+1, 1, 1)
                grid.attach(slaveLabelList[ps], 1, i+1, 1, 1)

                for slotID in range(2):
                    pss = (portID, slaveID, slotID)
                    if pss in self.__bias_64p.keys():
                        fileEntryList[pss] = Gtk.Entry()
                        grid.attach(fileEntryList[pss], 2+2*slotID, i+1, 1, 1)
                        fileEntryList[pss].set_margin_left(1)
                        fileEntryList[pss].set_width_chars(30)
                        fileEntryList[pss].set_max_width_chars(30)
                        fileButtonList[pss] = Gtk.Button("Choose")
                        grid.attach(fileButtonList[pss], 3+2*slotID, i+1, 1, 1)
                        fileButtonList[pss].connect("clicked", self.choose_BiasCal_File, pss, fileEntryList[pss])
                    elif pss in connection.getActiveBiasSlots():
                        label = Gtk.Label("PROM")
                        #label.set_property("halign", 3)
                        grid.attach(label, 2+2*slotID, i+1, 2, 1)
                    else:
                        label = Gtk.Label("N/A")
                        #label.set_property("halign", 3)
                        grid.attach(label, 2+2*slotID, i+1, 2, 1)

        
            febdConfigBox.show_all()
            febdConfigDialog = self.builder.get_object("febdConfigDialog")
            febdConfigDialog.connect("response", self.validate_response2, triggerSpinButtonList)
            response2 = febdConfigDialog.run()
        else:
            self.show_info_dialog(system_type_txt, topology_txt)

        if self.show_confirmation_dialog("Save configuration files in Working Data Folder?", "System configuration"):
            self.saveSystemSettings()
        else:
            self.show_info_dialog("System configuration not saved","")  
        return True
        
    def saveSystemSettings(self):
        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return
        
        if not os.path.exists(self.__workingFolder + "config.ini"):
            subprocess.call("cp config.ini "+self.__workingFolder, shell=True)

        map_cmd = ("./make_simple_channel_map -o %s/map " % self.__workingFolder)
        subprocess.call(map_cmd, shell=True)

        bias_cmd = [ "--port %d --slave %d --slot %d --filename %s" % (p,s,ss,fn) for (p,s,ss), fn in self.__bias_64p.items() ]
        bias_cmd = (" ").join(bias_cmd)
        bias_cmd = ("./make_bias_calibration_table -o %s/bias_calibration.tsv " % self.__workingFolder) + bias_cmd
        subprocess.call(bias_cmd, shell=True)

        self.show_info_dialog("System configuration saved","")
                
    def validate_response2(self, dialog, response_id, triggerSpinButtonList):
        if (response_id == -6):
            dialog.hide()
            return True

        valid = self.is_FEBD_Config_Valid()
        if valid:
            dialog.hide()
            
        return True
           
    def is_FEBD_Config_Valid(self):
        countFiles = Counter([fn for fn in self.__bias_64p.values() ])

        if (True, None) in  countFiles:
            self.show_error_dialog("Bias calibration file is not defined for all required FEB/Ds.")
            return False

        return True
                
    def choose_BiasCal_File(self, fileButton, pss, fileEntry):
        dialog = self.builder.get_object("biasCalFileChooser")
        dialog.set_transient_for(self.MainWindow)
        
        filter_file = Gtk.FileFilter()
        filter_file.set_name(".tsv files")
        filter_file.add_pattern("*.tsv")
        dialog.add_filter(filter_file)
        
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            if fileEntry != None:
                fileEntry.set_text(dialog.get_filename())
            
            self.__bias_64p[pss] = dialog.get_filename()
        dialog.hide()
        return response == Gtk.ResponseType.OK
            
    def on_asicCalStartButton_clicked(self, systemCalStartButton):
        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return
        
        if not self.is_daqd_running():
            self.show_error_dialog("daqd communication server is not running.")
            return
        
        if not os.path.exists(self.__workingFolder+"bias_settings.tsv"):
            self.show_error_dialog("Please save bias voltage settings (even if no SIPMs are connected).")
            return

        ask_cal = [True, True, True]
       
        ask_cal[0] = self.builder.get_object("asicCalCheckButton1").get_active()
        ask_cal[1] = self.builder.get_object("asicCalCheckButton2").get_active()
        ask_cal[2] = self.builder.get_object("asicCalCheckButton3").get_active()

        do_cal = ask_cal

        for i,f in enumerate(["disc_calibration.tsv", "tdc_calibration.tsv", "qdc_calibration.tsv"]):
            if os.path.exists(self.__workingFolder+f) and ask_cal[i]:
                do_cal[i] = self.show_confirmation_dialog("A calibration file '%s' already exists in the working folder. Overwrite?" % (f))

        if not any(do_cal):
            return
        
        confirm = True
        if do_cal[1] or do_cal[2]:
            confirm = self.show_confirmation_dialog("Calibration procedure can take more than 40 minutes to complete. Are you sure you want to proceed?")
        
        if not confirm:
            return True

        start = time()

        command = ""
        if do_cal[0]:
            command += "python3 -u ./acquire_threshold_calibration --config " + self.__workingFolder + "config.ini -o " + self.__workingFolder + "disc_calibration;"
            command += "python3 -u ./process_threshold_calibration --config " + self.__workingFolder + "config.ini -i " + self.__workingFolder + "disc_calibration -o " + self.__workingFolder+"disc_calibration.tsv --root-file "+self.__workingFolder+"/disc_calibration.root;"
            command += "python3 -u ./make_simple_disc_settings_table --config " + self.__workingFolder + "config.ini --vth_t1 20 --vth_t2 20 --vth_e 15 -o " + self.__workingFolder+"disc_settings.tsv;"
            
        if do_cal[1]:
            command += "python3 -u ./acquire_tdc_calibration --config " + self.__workingFolder+"config.ini -o " + self.__workingFolder + "tdc_calibration;"
            command += "./process_tdc_calibration --config " + self.__workingFolder + "config.ini -i " + self.__workingFolder + "tdc_calibration -o " + self.__workingFolder+"tdc_calibration;"

        if do_cal[2]:
            command += "python3 -u ./acquire_qdc_calibration --config " + self.__workingFolder+"config.ini -o " + self.__workingFolder+"qdc_calibration;"
            command += "./process_qdc_calibration --config " + self.__workingFolder+"config.ini -i " + self.__workingFolder + "qdc_calibration -o "+ self.__workingFolder+"qdc_calibration;"
            
        self.setPowerSwitchesStatus(True)

        self.execute(command,"ASIC Calibration","Calibration finished", "Please check calibration summary plots.")

        #end = time()
        
        #if ((end-start) < 300 and (do_cal[1] or do_cal[2])):
        #    self.show_error_dialog("Calibration finished too soon! Please check terminal output.")
        #else:
       #     self.show_info_dialog("Calibration finished","Please check calibration summary plots.")
                
    def on_temperatureStartupButton_clicked(self, button):
        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return
        
        if not self.is_daqd_running():
            self.show_error_dialog("daqd communication server is not running.")
            return
           
        self.setPowerSwitchesStatus(True)

        self.execute("python3 -u ./read_temperature_sensors --startup", "Check for temperature stability")
            
        #    self.show_info_dialog("Temperature is stable","ASIC(s) temperatures stable over the last minute. System ready to acquire.")
        #else:
        #    self.show_info_dialog("Temperature is unstable","ASIC(s) temperatures not stable over the last 10 minutes. Please ensure a stable temperature environment or proceed with measurements anyway")

    def on_temperatureReadButton_clicked(self, button):
        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return
                     
        if not self.is_daqd_running():    
            self.show_error_dialog("daqd communication server is not running.")
            return
    
        if not self.__initialiseTempPlot:
            self.fig = Figure(figsize=(50, 1), dpi=100)
            self.ax = self.fig.add_subplot(111)
            
            self.canvas = FigureCanvas(self.fig)  # a Gtk.DrawingArea
            self.canvas.set_size_request(300, 300)
            
            self.ax.plot()
            self.ax.set_xlabel('Time [seconds]',fontsize=10)
            self.ax.set_ylabel('Temperature [degrees Celsius]',fontsize=10)
            self.ax.tick_params(labelsize=10)

            self.readTempPlotWindow.add_with_viewport(self.canvas)
            self.__initialiseTempPlot = True

        self.readTempWindow.show_all()
       
        return True

    def on_readTempLogToggleButton_clicked(self, button):  
        if self.builder.get_object("readTempLogToggleButton").get_active():
              
            fileChooser = self.builder.get_object("tempLogFileChooser")
            fileChooser.set_transient_for(self.readTempWindow)
            if self.__workingFolder != None:
                fileChooser.set_current_folder(self.__workingFolder)

            filter_file = Gtk.FileFilter()
            filter_file.set_name("Temperature Log data")
            filter_file.add_pattern("*.tlog")
            fileChooser.add_filter(filter_file)

            response = fileChooser.run()
            if response == Gtk.ResponseType.OK:
                fileName = fileChooser.get_filename()
                if not fileName.endswith('.tlog'):
                    fileName = fileChooser.get_filename() + '.tlog'
                self.__tempLogFileName = fileName
               

            fileChooser.hide()
        else:
             self.__tempLogfileName = None
        
    def on_readTempStartButton_clicked(self, button):
        
        if self.__temperatureProcess is not None:
            return True

        interval = self.builder.get_object("readTempIntervalSpinButton").get_value()
        
        if self.__tempLogFileName is None:
            self.__tempLogFileName = "/tmp/log"
            
        self.setPowerSwitchesStatus(True)

        command = "python3 -u ./read_temperature_sensors -o %s --interval %s --time 259200" % (self.__tempLogFileName, interval ) 
  
        self.timeout_id = GObject.timeout_add(300, self.update_graph)
       
        self.read_temperature(command, "Read Temperature Sensors")
    
        return True   

    def update_graph(self):

        sensor_list = []
        time_list = []
        temp_values = {}
        with open(self.__tempLogFileName,'r') as f:
            reader = csv.reader(f, dialect = 'excel-tab')
            for row in reader:

                if row[0] == '#DAQ timestamp':
                    for item in row[2:]:
                        sensor_list.append(item)
                        temp_values[item] = []
                elif row[0][0] != '#':
                    for i, key in enumerate(sensor_list):
                        temp_values[key].append(float(row[2+i]))
                    time_list.append(float(row[1]))

        
        if not self.hasSensorInfo: 
            self.sensorCheckButtonList = [0 for x in sensor_list]     
            for i, sensor in enumerate(sensor_list):
                row = Gtk.ListBoxRow()
                hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing = 20)
                row.add(hbox)
                label = Gtk.Label(sensor,xalign=0)
                self.sensorCheckButtonList[i] = Gtk.CheckButton()
                self.sensorCheckButtonList[i].set_active(True)
                hbox.pack_start(label,True,True,0)
                hbox.add(self.sensorCheckButtonList[i])
                self.builder.get_object("readTempSensorListBox").add(row)
                #listbox.add(row)
                self.hasSensorInfo = True

        self.ax.cla()
        time_list = [time - time_list[0] for time in time_list]
        requestedSensors =[]
        requestedPlots = []
        for i, sensor in enumerate(sensor_list):
            if self.sensorCheckButtonList[i].get_active():
                plot, = self.ax.plot(time_list, temp_values[sensor], label = sensor)
                requestedPlots.append(plot,)
                requestedSensors.append(sensor)

        self.ax.set_xlabel('Time [seconds]',fontsize=10)
        self.ax.set_ylabel('Temperature [degrees Celsius]',fontsize=10)

        y_limits = self.ax.get_ylim()
        y_min = y_limits[0]
        y_max = y_limits[1]
        if y_min<0:
            y_min = 0
        if y_max>100:
            y_max = 100
        if y_max-y_min<1:
            y_max += 0.5
            y_min -= 0.5
        
        self.ax.set_ylim([y_min,y_max])

        self.ax.tick_params(labelsize=10)
    
        legend = self.ax.legend(requestedPlots, requestedSensors, fontsize = 'x-small', loc = 'upper right', ncol=2)
        legend.get_frame().set_alpha(0.5)
        self.canvas.draw()

        if  self.__usedTempStopButton:
            return False
        else:
            return True
    
    def on_readTempSelectSensorsButton_clicked(self, button):
        if(self.hasSensorInfo):
            self.builder.get_object("readTempSensorPopup").show_all()
            self.builder.get_object("readTempSensorPopup").popup()
            
    def on_readTempStopButton_clicked(self, button):
        if self.__temperatureProcess is not None:
            if self.show_confirmation_dialog("","Stop temperature monitoring?",  self.readTempWindow):
                self.__usedTempStopButton = True
                os.killpg(os.getpgid(self.__temperatureProcess.pid), signal.SIGTERM)
                self.ax.cla()
                self.ax.plot()
                self.canvas.draw()
                
                #GObject.source_remove(self.timeout_id)
        return True
        
    def on_femOnOffSwitch_state_set(self, switch, isOn):
        if not self.is_daqd_running():
            if not self.__fem_switch_handle_set: 
                self.show_error_dialog("daqd communication server is not running.")
                self.__fem_switch_handle_set = True
                self.builder.get_object("femOnOffSwitch").set_active(not isOn)
                self.__fem_switch_handle_set = False
            return True
            
        if isOn:
            if not self.__fem_switch_handle_set:              
                # if self.show_confirmation_dialog("Turn FEM power on?", parent = self.MainWindow):
                success = subprocess.call("./set_fem_power --power on", shell=True) == 0
                if success:
                    self.builder.get_object("biasOnOffLabel").set_sensitive(True)
                    self.builder.get_object("biasOnOffSwitch").set_sensitive(True)
                    return True
                self.__fem_switch_handle_set = True
                self.builder.get_object("femOnOffSwitch").set_active(False)
                self.__fem_switch_handle_set = False
                return True
        else:
            if not self.__fem_switch_handle_set:
                #if self.show_confirmation_dialog("Turn FEM power off?", parent = self.MainWindow):
                success = subprocess.call("./set_fem_power --power off", shell=True) == 0
                if success:
                    self.builder.get_object("biasOnOffLabel").set_sensitive(False)
                    self.builder.get_object("biasOnOffSwitch").set_sensitive(False)
                    return True
                self.__fem_switch_handle_set = True
                self.builder.get_object("femOnOffSwitch").set_active(True)
                self.__fem_switch_handle_set = False
                return True
  
    def on_biasOnOffSwitch_state_set(self, button, isOn):
        if not self.is_daqd_running(): 
            if not self.__bias_switch_handle_set: 
                self.show_error_dialog("daqd communication server is not running.")
                self.__bias_switch_handle_set = True
                self.builder.get_object("biasOnOffSwitch").set_active(not isOn)
                self.__bias_switch_handle_set = False
            return True
   
        if not os.path.exists(self.__workingFolder + "bias_settings.tsv"):
            if not self.__bias_switch_handle_set:
                self.show_error_dialog("Please save bias voltage settings")
                self.__bias_switch_handle_set = True
                self.builder.get_object("biasOnOffSwitch").set_active(not isOn)
                self.__bias_switch_handle_set = False
            return True
   
        if isOn:
            if not self.__bias_switch_handle_set:
                #if self.show_confirmation_dialog("Activate bias voltage lines?"):
                success = subprocess.call("./set_bias --power on", shell=True)== 0
                if success:
                    self.__bias_switch_handle_set = True
                    self.builder.get_object("biasOnOffSwitch").set_active(True)
                    self.__bias_switch_handle_set = False
                    return True
        else:
            if not self.__bias_switch_handle_set:
                #if self.show_confirmation_dialog("Deactivate bias voltage lines?"): 
                success = subprocess.call("./set_bias --power off", shell=True)== 0
                if success:
                    self.__bias_switch_handle_set = True
                    self.builder.get_object("biasOnOffSwitch").set_active(False)
                    self.__bias_switch_handle_set = False
                    return True
            
    def on_acqFileChooseButton_clicked(self, acqFileChooseButton):
        
        fileChooser = self.builder.get_object("acqFileChooser")
        fileEntry = self.builder.get_object("acqFileEntry")

        if self.__workingFolder != None:
            fileChooser.set_current_folder(self.__workingFolder)

        filter_file = Gtk.FileFilter()
        filter_file.set_name("Raw data")
        filter_file.add_pattern("*.rawf")
        fileChooser.add_filter(filter_file)

        response = fileChooser.run()
        if response == Gtk.ResponseType.OK:
            fileName = os.path.basename(fileChooser.get_filename())
            if fileName.endswith('.rawf'):
                fileName, ext = os.path.splitext(fileName)

            if ' ' in fileName:
                self.show_error_dialog("Please choose file name prefix without spaces")
                fileChooser.hide()
                return True

            fileEntry.set_text(fileName)
            self.builder.get_object("processingFileChooseEntry").set_text(fileName)
            
            dataType = self.builder.get_object("processingConvertBoxOptions").get_active_text()
            dataFormat = self.builder.get_object("processingDataFormatBoxOptions").get_active_text()

            if dataType == "Singles":
                extType = "_single"
            elif dataType == "Coincidences":
                extType = "_coinc"
            elif dataType == "Groups":
                extType = "_group"
            elif dataType == "Raw":
                extType = "_raw"

            if dataFormat == "Binary":
                extData = ".ldat"
            elif dataFormat == "ROOT":
                extData = ".root"
            else:
                extData = ".dat"

            self.builder.get_object("processingFileChooseEntry1").set_text(fileName+extType+extData)

        fileChooser.hide()
        
    def on_acqFileEntry_changed(self, entry):

        fileName = entry.get_text()

        if ' ' in fileName:
            self.show_error_dialog("Please choose file name prefix without spaces")
            return True

      
        if fileName == "":
            self.builder.get_object("processingFileChooseEntry").set_text("")
            self.builder.get_object("processingFileChooseEntry1").set_text("")
            return True
            
        

        self.builder.get_object("processingFileChooseEntry").set_text(fileName)

        dataType = self.builder.get_object("processingConvertBoxOptions").get_active_text()
        dataFormat = self.builder.get_object("processingDataFormatBoxOptions").get_active_text()

        if dataType == "Singles":
            extType = "_single"
        elif dataType == "Coincidences":
            extType = "_coinc"
        elif dataType == "Groups":
            extType = "_group"
        elif dataType == "Raw":
            extType = "_raw"

        if dataFormat == "Binary":
            extData = ".ldat"
        elif dataFormat == "ROOT":
            extData = ".root"
        else:
            extData = ".dat"

        self.builder.get_object("processingFileChooseEntry1").set_text(fileName+extType+extData)


    def on_acqRealTimeProcess_state_set(self, switch, isOn):
        if isOn:
            self.builder.get_object("acqSaveRawLabel").set_sensitive(True)
            self.builder.get_object("acqSaveRawCheck").set_sensitive(True)
            self.builder.get_object("acqProcessWhenFinishedLabel").set_sensitive(False)
            self.builder.get_object("acqProcessWhenFinishedCheck").set_sensitive(False)
            self.builder.get_object("acqProcessWhenFinishedCheck").set_active(False)
            switch.set_active(True)
            return True
        else:
            self.builder.get_object("acqSaveRawLabel").set_sensitive(False)
            self.builder.get_object("acqSaveRawCheck").set_sensitive(False)
            self.builder.get_object("acqSaveRawCheck").set_active(False)
            self.builder.get_object("acqProcessWhenFinishedLabel").set_sensitive(True)
            self.builder.get_object("acqProcessWhenFinishedCheck").set_sensitive(True)
            switch.set_active(False)
            return False


    def on_acqAcquireButton_clicked(self, acqFileChooseButton):   

        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return
        
        if not self.is_daqd_running():   
            self.show_error_dialog("daqd communication server is not running.")
            return
       
        if not os.path.exists(self.__workingFolder + "bias_settings.tsv"):
            self.show_error_dialog("Please save bias voltage settings.")
            return
            
        if not os.path.exists(self.__workingFolder + "disc_settings.tsv"):
            self.show_error_dialog("Please save threshold settings.")
            return

        if self.builder.get_object("acqFileEntry").get_text() == "":
            self.show_error_dialog("Please choose an output file name.")
            return

        outFile = self.__workingFolder+self.builder.get_object("acqFileEntry").get_text()

        if outFile.endswith('.rawf'):
            fileName, ext = os.path.splitext(fileName)

        if ' ' in outFile:
            self.show_error_dialog("Please choose file name prefix without spaces")
            return
    

        mode = self.builder.get_object("acqModeOptionsBox").get_active_text()
        time = self.builder.get_object("acqTimeSpinButton").get_value()
        if time == 0:
            self.show_error_dialog("Acquision duration time set to 0. Please choose a valid acquisition duration time.")
            return

        useTrigger = self.builder.get_object("acqTrigger").get_active()
        onlineProcess = self.builder.get_object("acqRealTimeProcess").get_active()
        
        if( not onlineProcess or (onlineProcess and self.builder.get_object("acqSaveRawCheck").get_active())):
            if os.path.exists(outFile+".rawf"):
                if not self.show_confirmation_dialog("Raw data file '%s.rawf' exists in the working data folder. Overwrite?" % (self.builder.get_object("acqFileEntry").get_text())):
                    return True


        if useTrigger:
            flag = "--enable-hw-trigger"

        else:
            flag = ""


        if(onlineProcess):
            format = ""
            flag += " --enableOnlineProcessing"
            flagType, flagFormat, flagFraction, flagHits, flagTimeRef = self.getProcessingOptions(outFile)
            if flagFormat == "--writeBinary":
                format = "binary"
            elif flagFormat == "--writeBinaryCompact":
                format = "binaryCompact"
            elif flagFormat == "--writeRoot":
                format = "root"
            elif flagFormat == "--writeTextCompact":
                format = "textCompact"
            elif flagFormat == "":
                format = "text"   

            flag += " --outputType %s --outputFormat %s %s %s %s" % (flagType, format, flagFraction, flagHits, flagTimeRef) 
            if self.builder.get_object("acqSaveRawCheck").get_active(): 
                flag += " --writeRawData"
    
      
        doDelayStart = self.builder.get_object("acqManualStart").get_active()

        if(doDelayStart):
            if os.path.exists("/tmp/aquisition_starting_fifo"):
                os.remove("/tmp/aquisition_starting_fifo")
            fifo = os.mkfifo("/tmp/aquisition_starting_fifo")
            flag += "--wait-on /tmp/aquisition_starting_fifo"   
            self.builder.get_object("execStartButton").set_sensitive(True)

        command = "python3 -u ./acquire_sipm_data --config %sconfig.ini -o %s --mode %s --time %.2f %s;" % (self.__workingFolder, outFile, mode.lower(), time, flag)

        if (not self.builder.get_object("acqProcessWhenFinishedCheck").get_active()):
            self.startAcquisition(command, onlineProcess)
        else:
            self.builder.get_object("execStartButton").set_sensitive(False) 
            
            
            inFileName = self.builder.get_object("processingFileChooseEntry").get_text()
            
            if inFileName.endswith('.rawf'):
                inFileName, ext = os.path.splitext(inFileName)

            outFileName = self.builder.get_object("processingFileChooseEntry1").get_text()
            inFile = self.__workingFolder + inFileName
            outFile = self.__workingFolder + outFileName

            flagType, flagFormat, flagFraction, flagHits, flagTimeRef= self.getProcessingOptions(outFileName)

            if flagType == "singles":
                command += "./convert_raw_to_singles --config %sconfig.ini -i %s -o %s %s %s %s %s" % (self.__workingFolder, inFile, outFile, flagFormat, flagFraction, flagHits, flagTimeRef) 
            if flagType == "coincidences":
                command += "./convert_raw_to_coincidence --config %sconfig.ini -i %s -o %s %s %s %s %s" % (self.__workingFolder, inFile, outFile, flagFormat, flagFraction, flagHits, flagTimeRef)
            if flagType == "groups":
                command += "./convert_raw_to_group --config %sconfig.ini -i %s -o %s %s %s %s %s" % (self.__workingFolder, inFile, outFile, flagFormat, flagFraction, flagHits, flagTimeRef)
            if flagType == "raw":
                command += "./convert_raw_to_raw --config %sconfig.ini -i %s -o %s %s" % (self.__workingFolder, inFile, outFile, flagFormat)

         
            self.setPowerSwitchesStatus(True)

            self.execute(command, "Raw data Acquisition and Processing", "Finished Data Acquisition and Processing","")

            if(doDelayStart):
                self.builder.get_object("execStartButton").set_sensitive(True)

            
        return True
        
        
    
    def startAcquisition(self, command, onlineProcessing=False):
        self.setPowerSwitchesStatus(True)
        if onlineProcessing:
            self.execute(command, "Data Acquisition with Real-time Processing", "Data Acquisition Finished", "")
        else:
            self.execute(command, "Data Acquisition", "Data Acquisition Finished", "")
    

    def on_execStartButton_clicked(self, button):
        self.builder.get_object("execStartButton").set_sensitive(False)
        with open("/tmp/aquisition_starting_fifo", "w") as fifo:
            fifo.write("start")

        return True
    
    def on_processingConvertBoxOptions_changed(self, comboBox):

        dataType =  self.builder.get_object("processingConvertBoxOptions").get_active_text()

        if dataType in ("Groups","Coincidences"):
            self.builder.get_object("processingLabel5").set_sensitive(True)
            self.builder.get_object("processingHitsSpinButton").set_sensitive(True)
            extType = (dataType == "Groups") and "_group" or "_coinc"
        else:
            self.builder.get_object("processingLabel5").set_sensitive(False)
            self.builder.get_object("processingHitsSpinButton").set_sensitive(False)
    
        if dataType == "Raw":
            extType = "_raw"
            self.builder.get_object("processingDataFormatBoxOptions").remove_all()
            self.builder.get_object("processingDataFormatBoxOptions").insert_text(0,"Text")
            self.builder.get_object("processingDataFormatBoxOptions").insert_text(1,"ROOT")
            self.builder.get_object("processingDataFormatBoxOptions").set_active(0)
            self.builder.get_object("processingLabel6").set_sensitive(False)
            self.builder.get_object("processingTimeReferenceBoxOptions").set_sensitive(False)
        
        elif dataType == "Singles":
            self.builder.get_object("processingDataFormatBoxOptions").remove_all()
            self.builder.get_object("processingDataFormatBoxOptions").insert_text(0,"Binary")
            self.builder.get_object("processingDataFormatBoxOptions").insert_text(1,"Text")
            self.builder.get_object("processingDataFormatBoxOptions").insert_text(2,"ROOT")
            self.builder.get_object("processingDataFormatBoxOptions").set_active(0)
            self.builder.get_object("processingLabel6").set_sensitive(True)
            self.builder.get_object("processingTimeReferenceBoxOptions").set_sensitive(True)
        else:
            self.builder.get_object("processingDataFormatBoxOptions").remove_all()
            self.builder.get_object("processingDataFormatBoxOptions").insert_text(0,"BinaryComp")
            self.builder.get_object("processingDataFormatBoxOptions").insert_text(1,"Binary")
            self.builder.get_object("processingDataFormatBoxOptions").insert_text(2,"Text")
            self.builder.get_object("processingDataFormatBoxOptions").insert_text(3,"TextComp")
            self.builder.get_object("processingDataFormatBoxOptions").insert_text(4,"ROOT")

            self.builder.get_object("processingDataFormatBoxOptions").set_active(0)
            self.builder.get_object("processingLabel6").set_sensitive(True)
            self.builder.get_object("processingTimeReferenceBoxOptions").set_sensitive(True)
           

        if dataType == "Singles":       
            extType = "_single"

        dataFormat =  self.builder.get_object("processingDataFormatBoxOptions").get_active_text()
       
        if dataFormat == "Binary":
            extData = ".ldat"
        elif dataFormat == "ROOT":
            extData = ".root"
        else:
            extData = ".dat"
            
        if self.builder.get_object("processingFileChooseEntry").get_text() != "":
            fileName = self.builder.get_object("processingFileChooseEntry").get_text() 
            self.builder.get_object("processingFileChooseEntry1").set_text(fileName+extType+extData)
   
    def on_processingDataFormatBoxOptions_changed(self, comboBox):
        dataType =  self.builder.get_object("processingConvertBoxOptions").get_active_text()
        dataFormat =  self.builder.get_object("processingDataFormatBoxOptions").get_active_text()
        
        if dataType == "Singles":
            extType = "_single"
        elif dataType == "Coincidences":
            extType = "_coinc"
        elif dataType == "Groups":
            extType = "_group"
        elif dataType == "Raw":
            extType = "_raw"

        active = self.builder.get_object("processingTimeReferenceBoxOptions").get_active()
        self.builder.get_object("processingTimeReferenceBoxOptions").remove_all()
        self.builder.get_object("processingTimeReferenceBoxOptions").insert_text(0,"Sync")
        self.builder.get_object("processingTimeReferenceBoxOptions").insert_text(1,"User")
        self.builder.get_object("processingTimeReferenceBoxOptions").insert_text(2,"Wall")
        self.builder.get_object("processingTimeReferenceBoxOptions").set_active(active)

        if dataFormat == "Binary":
            extData = ".ldat"
        elif dataFormat == "ROOT":
            extData = ".root"
        else:
            extData = ".dat"
            self.builder.get_object("processingTimeReferenceBoxOptions").remove_all()
            self.builder.get_object("processingTimeReferenceBoxOptions").insert_text(0,"Sync")
            self.builder.get_object("processingTimeReferenceBoxOptions").insert_text(1,"User")
            if active == 2:
                self.builder.get_object("processingTimeReferenceBoxOptions").set_active(0)
            else:
                self.builder.get_object("processingTimeReferenceBoxOptions").set_active(active)

        if self.builder.get_object("processingFileChooseEntry").get_text() != "":
            fileName = self.builder.get_object("processingFileChooseEntry").get_text() 
            self.builder.get_object("processingFileChooseEntry1").set_text(fileName+extType+extData)
        
    def on_processingFileChooseButton_clicked(self, button):
        fileChooser = self.builder.get_object("processingFileChooserDialog")
        fileEntry = self.builder.get_object("processingFileChooseEntry")
        fileEntry1 = self.builder.get_object("processingFileChooseEntry1")

        if self.__workingFolder != None:
            fileChooser.set_current_folder(self.__workingFolder)

        filter_file = Gtk.FileFilter()
        filter_file.set_name("Raw data")
        filter_file.add_pattern("*.rawf")
        fileChooser.add_filter(filter_file)

        response = fileChooser.run()
        if response == Gtk.ResponseType.OK:
            fileName, ext = os.path.splitext(os.path.basename(fileChooser.get_filename()))
            fileEntry.set_text(fileName)
            dataType = self.builder.get_object("processingConvertBoxOptions").get_active_text()
            dataFormat = self.builder.get_object("processingDataFormatBoxOptions").get_active_text()
            
            if dataType == "Singles":
                extType = "_single"
            elif dataType == "Coincidences":
                extType = "_coinc"
            elif dataType == "Groups":
                extType = "_group"
            elif dataType == "Raw":
                extType = "_raw"
         
            if dataFormat == "Binary":
                extData = ".ldat"
            elif dataFormat == "ROOT":
                extData = ".root"
            else:
                extData = ".dat"
            fileEntry1.set_text(fileName+extType+extData)
            fileChooser.hide()
        elif response == Gtk.ResponseType.CANCEL:
            fileChooser.hide()
        
    def on_processingFileChooseButton1_clicked(self, button):
        fileChooser = self.builder.get_object("processingFileChooserDialog1")
        fileEntry = self.builder.get_object("processingFileChooseEntry1")

        if self.__workingFolder != None:
            fileChooser.set_current_folder(self.__workingFolder)

        filter_file = Gtk.FileFilter()
        filter_file.set_name("Raw data")
        filter_file.add_pattern("*.rawf")
        fileChooser.add_filter(filter_file)

        response = fileChooser.run()
        if response == Gtk.ResponseType.OK:
            fileName, ext = os.path.splitext(os.path.basename(fileChooser.get_filename()))
            fileEntry.set_text(fileName)
            fileChooser.hide()
        elif response == Gtk.ResponseType.CANCEL:
            fileChooser.hide()
        
    def on_processingFileChooseEntry_changed(self, dataFolderEntry):
        fileName = self.builder.get_object("processingFileChooseEntry").get_text()
        if fileName.endswith('.rawf'):
            fileName, ext = os.path.splitext(fileName)
        
        if fileName == "":
            self.builder.get_object("processingFileChooseEntry1").set_text("")
            return True
        
        dataType = self.builder.get_object("processingConvertBoxOptions").get_active_text()
        dataFormat = self.builder.get_object("processingDataFormatBoxOptions").get_active_text()

        if dataType == "Singles":
            extType = "_single"
        elif dataType == "Coincidences":
            extType = "_coinc"
        elif dataType == "Groups":
            extType = "_group"
        elif dataType == "Raw":
            extType = "_raw"
         
        if dataFormat == "Binary":
            extData = ".ldat"
        elif dataFormat == "ROOT":
            extData = ".root"
        else:
            extData = ".dat"

        self.builder.get_object("processingFileChooseEntry1").set_text(fileName+extType+extData)
        return True
    
    
    def getProcessingOptions(self, outFile):
        dataType = self.builder.get_object("processingConvertBoxOptions").get_active_text()
        dataFormat = self.builder.get_object("processingDataFormatBoxOptions").get_active_text()
        fraction = self.builder.get_object("processingFractionSpinButton").get_value()
        timeRef = self.builder.get_object("processingTimeReferenceBoxOptions").get_active_text()

        if dataType == "Singles":
            flagType = "singles"
        elif dataType == "Coincidences":
            flagType = "coincidences"
        elif dataType == "Groups":
            flagType = "groups"
        elif dataType == "Raw":
            flagType = "raw"
        
        if dataType != "Raw" and not os.path.exists(self.__workingFolder + "tdc_calibration.tsv"):
            self.show_error_dialog("TDC calibration file not found in working folder. Please perform ASIC calibration.")
            return True
        
        if dataFormat == "Binary":
            flagFormat = "--writeBinary"
            if outFile.endswith('.ldat'):
                outFile, ext = os.path.splitext(outFile)
        elif dataFormat == "BinaryComp":
            flagFormat = "--writeBinaryCompact"
            if outFile.endswith('.ldat'):
                outFile, ext = os.path.splitext(outFile)
        elif dataFormat == "ROOT":
            flagFormat = "--writeRoot"
        elif dataFormat == "TextComp":
            flagFormat = "--writeTextCompact"
        else:
            flagFormat = ""
        
        flagFraction = "--writeFraction %d" % (fraction)

        if dataType in ("Groups","Coincidences"):
            nHits = self.builder.get_object("processingHitsSpinButton").get_value_as_int()
            flagHits = "--writeMultipleHits %d" % (nHits)
        else:
            flagHits = ""
       
        if timeRef == "Sync":
            timeRefFlag = "sync"
        elif timeRef == "Wall":
            timeRefFlag = "wall"
        elif timeRef == "User":
            timeRefFlag = "user"
        flagTimeRef = "--timeref %s" % (timeRefFlag)

        return flagType, flagFormat, flagFraction, flagHits, flagTimeRef
    

    
    def on_processButton_clicked(self, button):
        if self.__workingFolder == None:
            self.show_error_dialog("Please choose a working folder.")
            return True

        fileName = self.builder.get_object("processingFileChooseEntry").get_text()
        fileExists = os.path.exists(self.__workingFolder+fileName) or os.path.exists(self.__workingFolder+fileName+".rawf")
        if not fileExists:
            self.show_error_dialog("Raw file doesn't exist. Please enter an existing file or use the Choose button.")
            return True

        inFileName = self.builder.get_object("processingFileChooseEntry").get_text()
        
        if inFileName == "":
            self.show_error_dialog("Please choose a file to process.")
            return True
        
        if inFileName.endswith('.rawf'):
            inFileName, ext = os.path.splitext(inFileName)

        outFileName = self.builder.get_object("processingFileChooseEntry1").get_text()
        inFile = self.__workingFolder + inFileName
        outFile = self.__workingFolder + outFileName

        flagType, flagFormat, flagFraction, flagHits, flagTimeRef= self.getProcessingOptions(outFileName)



        if flagType == "singles":
            command = "./convert_raw_to_singles --config %sconfig.ini -i %s -o %s %s %s %s %s" % (self.__workingFolder, inFile, outFile, flagFormat, flagFraction, flagHits, flagTimeRef) 
        if flagType == "coincidences":
            command = "./convert_raw_to_coincidence --config %sconfig.ini -i %s -o %s %s %s %s %s" % (self.__workingFolder, inFile, outFile, flagFormat, flagFraction, flagHits, flagTimeRef)
        if flagType == "groups":
            command = "./convert_raw_to_group --config %sconfig.ini -i %s -o %s %s %s %s %s" % (self.__workingFolder, inFile, outFile, flagFormat, flagFraction, flagHits, flagTimeRef)
        if flagType == "raw":
            command = "./convert_raw_to_raw --config %sconfig.ini -i %s -o %s %s" % (self.__workingFolder, inFile, outFile, flagFormat)
        
        self.execute(command, "Raw data Processing", "Finished Data Processing", "")
    
        return True

    def show_error_dialog(self, string):
        dialog = Gtk.MessageDialog(parent = self.MainWindow, flags = 0, message_type = Gtk.MessageType.ERROR, buttons = Gtk.ButtonsType.OK, text = string)
        dialog.format_secondary_text(string)
        dialog.run()
        dialog.destroy()

    def show_confirmation_dialog(self, query, title = "WARNING", parent = None):
        if parent is None:
            parent = self.MainWindow

        dialog = Gtk.MessageDialog(parent = parent, flags = 0, message_type = Gtk.MessageType.QUESTION, buttons = Gtk.ButtonsType.YES_NO, text = title)
        dialog.format_secondary_text(query)     
        rtn = dialog.run() 
        dialog.destroy()
        return rtn == Gtk.ResponseType.YES

    def show_info_dialog(self, title, text, parent = None):
        if parent is None:
            parent = self.MainWindow
        dialog = Gtk.MessageDialog(parent = parent, flags = 0, message_type = Gtk.MessageType.INFO, buttons = Gtk.ButtonsType.OK, text = title)
        dialog.format_secondary_text(text)
        dialog.run()
        dialog.destroy()

def main():
    gui = GUI()
    gui.MainWindow.show()
    Gtk.main()
    return 0

if __name__ == "__main__":  
    sys.exit(main())
